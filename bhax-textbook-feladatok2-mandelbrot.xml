<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Reverse engineering UML osztálydiagram</title>
        <para>UML osztálydiagram raj
zolása az első védési C++ programhoz. Az osztálydiagramot a forrásokból
generáljuk (pl. Argo UML, Umbrello, Eclipse UML) Mutassunk rá a kompozíció és aggregáció
kapcsolatára a forráskódban és a diagramon, lásd még: https://youtu.be/Td_nlERlEOs
Lásd fóliák!
        </para>
        <para>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:   
            
             <mediaobject>
                <imageobject>
                    <imagedata fileref="Helló, Mandelbrot!/Reverse engineering UML osztálydiagram/BinFaUML2.png" scale="70" />
                </imageobject>   
                
            </mediaobject>   
            
              
        
        </para>
        <para>Az osztálydiagram az osztályok közötti kapcsolatot képviseli a programban.
        	A két osztály két kék színű téglalap. Az téglalap felső része az osztály attribútumait az alsó a metódusait tartalmazza.
        	A láthatóságukat az elötte lévő jelek is megmutatják.</para>
        
        <para>+ azaz public</para>
        <para>- azaz private</para>
        <para># azaz protected</para>

        <para>A feladat külön kéri, hogy térjünk ki a kompozíció és aggregáció kapcsolatára.</para>
	<para>	Aggregációról akkor beszélhetünk, amikor az egyik objektum részben (vagy akár egészben) is tartalmazza
		a másikat. Két típusú van: </para>
         <para>erős</para>
        <para>gyenge</para>
        <para>A gyenge aggregációt nevezzük kompozíciónak, azaz a tartamazott objektum illetve a tartalmazó objektum függnek egymástól. Egymás nélkül nem funkcionálnak.

        </para>
        
        
    </section>       

    <section>
    <title>Forward engineering UML osztálydiagram</title>
    <para>UML
ben tervezzünk osztályokat és generáljunk belőle forrást!</para>
    <para></para>

    <para>
            Megoldás videó:
    </para>
    <para>
            Megoldás forrása:   <mediaobject>
                <imageobject>
                    <imagedata fileref="Helló, Mandelbrot!/Forward engineering UML osztálydiagram/BinFaUML.png" scale="70" />
                </imageobject>   
                
            </mediaobject> 
    </para>
    <para>A "Tools" menünk belül a "Code", majd a "Generate C++" lehetőséget választjuk, hogy legenerálja nekünk a forrást.
    </para>
    <programlisting language="c++">

#include "Csomopont.h"

void Csomopont::egyesGyermek() {
	// TODO - implement Csomopont::egyesGyermek
	throw "Not yet implemented";
}

void Csomopont::nullasGyermek() {
	// TODO - implement Csomopont::nullasGyermek
	throw "Not yet implemented";
}

void Csomopont::getBetu() {
	// TODO - implement Csomopont::getBetu
	throw "Not yet implemented";
}

Csomopont::Csomopont(char aB) {
	// TODO - implement Csomopont::Csomopont
	throw "Not yet implemented";
}

void Csomopont::_Csomopont() {
	// TODO - implement Csomopont::_Csomopont
	throw "Not yet implemented";
}

void Csomopont::ujEgyesGyermek(Csomopont* aGy) {
	// TODO - implement Csomopont::ujEgyesGyermek
	throw "Not yet implemented";
}

void Csomopont::ujNullasGyermek(Csomopont* aGy) {
	// TODO - implement Csomopont::ujNullasGyermek
	throw "Not yet implemented";
}

Csomopont::Csomopont(Csomopont const& aUnnamed_1) {
	// TODO - implement Csomopont::Csomopont
	throw "Not yet implemented";
}

void Csomopont::_(Csomopont const& aUnnamed_1) {
	// TODO - implement Csomopont::_
	throw "Not yet implemented";
}


    </programlisting>

    </section>





</chapter>
                 
