<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Reverse engineering UML osztálydiagram</title>
        <para>UML osztálydiagram raj
zolása az első védési C++ programhoz. Az osztálydiagramot a forrásokból
generáljuk (pl. Argo UML, Umbrello, Eclipse UML) Mutassunk rá a kompozíció és aggregáció
kapcsolatára a forráskódban és a diagramon, lásd még: https://youtu.be/Td_nlERlEOs
Lásd fóliák!
        </para>
        <para>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:   
            
             <mediaobject>
                <imageobject>
                    <imagedata fileref="Helló, Mandelbrot!/Reverse engineering UML osztálydiagram/BinFaUML2.png" scale="70" />
                </imageobject>   
                
            </mediaobject>   
            
              
        
        </para>
        <para>Az osztálydiagram az osztályok közötti kapcsolatot képviseli a programban.
        	A két osztály két kék színű téglalap. Az téglalap felső része az osztály attribútumait az alsó a metódusait tartalmazza.
        	A láthatóságukat az elötte lévő jelek is megmutatják.</para>
        
        <para>+ azaz public</para>
        <para>- azaz private</para>
        <para># azaz protected</para>

        <para>A feladat külön kéri, hogy térjünk ki a kompozíció és aggregáció kapcsolatára.</para>
	<para>	Aggregációról akkor beszélhetünk, amikor az egyik objektum részben (vagy akár egészben) is tartalmazza
		a másikat. Két típusú van: </para>
         <para>erős</para>
        <para>gyenge</para>
        <para>A gyenge aggregációt nevezzük kompozíciónak, azaz a tartamazott objektum illetve a tartalmazó objektum függnek egymástól. Egymás nélkül nem funkcionálnak.

        </para>
        
        
    </section>       

    <section>
    <title>Forward engineering UML osztálydiagram</title>
    <para>UML
ben tervezzünk osztályokat és generáljunk belőle forrást!</para>
    <para></para>

    <para>
            Megoldás videó:
    </para>
    <para>
            Megoldás forrása:  
             <mediaobject>
                <imageobject>
                    <imagedata fileref="Helló, Mandelbrot!/Forward engineering UML osztálydiagram/BinFaUML.png" scale="45" />
                </imageobject>   
                
            </mediaobject> 
    </para>
    <para>A "Tools" menünk belül a "Code", majd a "Generate C++" lehetőséget választjuk, hogy legenerálja nekünk a forrást.
    </para>
    <programlisting language="c++"><![CDATA[

#include "Csomopont.h"

void Csomopont::egyesGyermek() {
	// TODO - implement Csomopont::egyesGyermek
	throw "Not yet implemented";
}

void Csomopont::nullasGyermek() {
	// TODO - implement Csomopont::nullasGyermek
	throw "Not yet implemented";
}

void Csomopont::getBetu() {
	// TODO - implement Csomopont::getBetu
	throw "Not yet implemented";
}

Csomopont::Csomopont(char aB) {
	// TODO - implement Csomopont::Csomopont
	throw "Not yet implemented";
}

void Csomopont::_Csomopont() {
	// TODO - implement Csomopont::_Csomopont
	throw "Not yet implemented";
}

void Csomopont::ujEgyesGyermek(Csomopont* aGy) {
	// TODO - implement Csomopont::ujEgyesGyermek
	throw "Not yet implemented";
}

void Csomopont::ujNullasGyermek(Csomopont* aGy) {
	// TODO - implement Csomopont::ujNullasGyermek
	throw "Not yet implemented";
}

Csomopont::Csomopont(Csomopont const& aUnnamed_1) {
	// TODO - implement Csomopont::Csomopont
	throw "Not yet implemented";
}

void Csomopont::_(Csomopont const& aUnnamed_1) {
	// TODO - implement Csomopont::_
	throw "Not yet implemented";
}
]]>


    </programlisting>
    <para></para>
    <para></para>
    <para></para>
    <programlisting language="c++"><![CDATA[
#ifndef CSOMOPONT_H
#define CSOMOPONT_H

class Csomopont {

private:
	char betu;
	Csomopont jobbEgy;
	Csomopont balNulla;

public:
	void egyesGyermek();

	void nullasGyermek();

	void getBetu();

	Csomopont(char aB = '/');

	void _Csomopont();

	void ujEgyesGyermek(Csomopont* aGy);

	void ujNullasGyermek(Csomopont* aGy);

private:
	Csomopont(Csomopont const& aUnnamed_1);

	void _(Csomopont const& aUnnamed_1);
};

#endif


]]>


    </programlisting>
    <para></para>
    <para></para>
    <para></para>
    <programlisting language="c++"><![CDATA[
#include "LZWBinFa.h"

void LZWBinFa::_LZWBinFa() {
	// TODO - implement LZWBinFa::_LZWBinFa
	throw "Not yet implemented";
}

void LZWBinFa::getMelyseg() {
	// TODO - implement LZWBinFa::getMelyseg
	throw "Not yet implemented";
}

void LZWBinFa::getAtlag() {
	// TODO - implement LZWBinFa::getAtlag
	throw "Not yet implemented";
}

void LZWBinFa::getSzoras() {
	// TODO - implement LZWBinFa::getSzoras
	throw "Not yet implemented";
}

void LZWBinFa::_() {
	// TODO - implement LZWBinFa::_
	throw "Not yet implemented";
}

void LZWBinFa::szabadit() {
	// TODO - implement LZWBinFa::szabadit
	throw "Not yet implemented";
}

void LZWBinFa::rmelyseg() {
	// TODO - implement LZWBinFa::rmelyseg
	throw "Not yet implemented";
}

void LZWBinFa::ratlag() {
	// TODO - implement LZWBinFa::ratlag
	throw "Not yet implemented";
}

void LZWBinFa::rszoras() {
	// TODO - implement LZWBinFa::rszoras
	throw "Not yet implemented";
}


]]>


    </programlisting>
    <para></para>
    <para></para>
    <para></para>
    <programlisting language="c++"><![CDATA[

#ifndef LZWBINFA_H
#define LZWBINFA_H

class LZWBinFa {

protected:
	Csomopont _gyoker;
private:
	int _melyseg;
	int _atlagosszeg;
	int _atlagdb;
	double _szorasosszeg;
protected:
	int _maxMelyseg;
	double _atlag;
	double _szoras;

public:
	void _LZWBinFa();

	void getMelyseg();

	void getAtlag();

	void getSzoras();

	LZWBinFa();

	void kiir();

private:
	void _();

	void szabadit();

protected:
	void rmelyseg();

	void ratlag();

	void rszoras();
};

#endif
]]>


    </programlisting>

    </section>
    <section>
        <title>Neptun tantárgyfelvétel modellezése UML ben</title>
        <para>Modellezd le a Neptun rendszer tárgyfelvételéhez szükséges objektumokat UML diagramm segítségével.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: 
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Helló, Mandelbrot!/Neptun tantárgyfelvétel modellezése UML ben/Neptun.png" scale="70" />
                </imageobject>   
                
            </mediaobject>  
        </para>
        <para>
            
        </para>
    </section> 
     <section>
        <title>Neptun tantárgyfelvétel UML diagram implementálása</title>
        <para>Implementáld le az előző feladatban létrehozott diagrammot egy tetszőleges nyelven.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Mandelbrot!/Neptun%20tant%C3%A1rgyfelv%C3%A9tel%20UML%20diagram%20implement%C3%A1l%C3%A1sa/c%2B%2B"> C++ </link>
            
            
            
             <link xlink:href="https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Mandelbrot!/Neptun%20tant%C3%A1rgyfelv%C3%A9tel%20UML%20diagram%20implement%C3%A1l%C3%A1sa/java"> java </link>
             
             
        </para>
        <para>
            
        </para>
    </section>  
    
    
    
    
    





</chapter>
                 
