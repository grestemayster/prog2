<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>OO szemlélet</title>
        <para>A módosított polártranszformációs normális generátor beprogramozása Java nyelven. Mutassunk rá, hogy a mi természetes saját megoldásunk (az algoritmus egyszerre két normálist állít elő, kell egy példánytag, amely a nem visszaadottat tárolja és egy logikai tag, hogy van-e tárolt vagy futtatni kell az algot.) és az OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf(16-22 fólia)Ugyanezt írjuk meg C++ nyelven is! (lásd még UDPROG repó: source/labor/polargen)
        </para>
        <para>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Arroway!/oo ">https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Arroway!/oo</link>               
        </para>
        <para>
        Az algoritmus elkészítése "public" "PolárGenerátor" osztályban történik.
        Deklarálunk egy "nincsTárolt" változót is, amely "boolean" típusú.
        Deklarálunk egy "tárolt" változót is, amely "double" típusú.
        Deklarálunk egy "következő" "double" típusú fgv-t is.
        Amennyiben a "nincsTárolt" igaz,
        	akkor egy do-while cikluson belül a "Math.random+ függvényt használva "u1" illetve "u2" egy véletlen értéket kap, addig ameddig "w" nagyobb mint 1. "v1" illetve "v2" megkapja az előző változók értékeit, ahogy "w" is. Utána kiszámoljuk az "r" értékét is, ahol már a "tárolt" változónk is értéket kap.
        Ha hamis,
        	akkor a fgv a már eltárolt elemet adja vissza.
                </para>
    </section>        

    <section>
        <title>„Gagyi”</title>
        <para>Az  ismert  formális2„while  x  &lt;=  t  &amp;&amp;  x  &gt;=  t  &amp;&amp;  t  !=  x);” tesztkérdéstípusraadj  a  szokásosnál (miszerint  x,  t  az  egyik  esetben  az  objektum  által  hordozott  érték,  a  másikban  meg  az  objektum referenciája) „mélyebb” választ,  írj  Java  példaprogramot  mely  egyszer  végtelen  ciklus,  más  x,  t értékekkel meg nem! A példát építsd a JDK Integer.java forrására3, hogy a 128-nál inkluzív objektum példányokat poolozza!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Arroway!/Gagyi">   https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Arroway!/Gagyi </link>             
        </para>
        <para>
            
        </para>
    </section>  
    
    <section>
        <title>Yoda</title>
        <para>YodaÍrjunk  olyan  Java  programot,  ami  java.lang.NullPointerEx-el  leáll,  ha  nem  követjük  a  Yoda conditions-t! https://en.wikipedia.org/wiki/Yoda_conditions
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Arroway!/Yoda">    https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Arroway!/Yoda  </link>          
        </para>
        <para>
            
        </para>
    </section> 
    
    <section>
        <title>Homokózó</title>
        <para>Írjuk át az első védési programot (LZW binfa) C++ nyelvről Java nyelvre, ugyanúgy működjön! Mutassunk rá, hogy gyakorlatilag a pointereket és referenciákat kell kiirtani és minden máris működik (erre  utal  a  feladat  neve,  hogy  Java-ban  minden  referencia,  nincs  választás,  hogy  mondjuk  egy attribútum pointer, referencia vagy tagként tartalmazott legyen).Miután  már áttettük Java  nyelvre, tegyük  be egy  Java Servletbe és a böngészőből GET-es kéréssel (például a böngésző címsorából) kapja meg azt a mintát, amelynek kiszámolja az LZW binfáját!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Arroway!/LZWBinFa">https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Arroway!/LZWBinFa</link>        
        </para>
        <para>
            
        </para>
    </section>       
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
