<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Liskov!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Anti OO</title>
        <para>
        A BBP algoritmussal a Pi hexadecimális kifejtésének a 0. pozíciótól számított 10^6, 10^7, 10^8darab jegyét határozzuk meg C, C++, Java és C# nyelveken és vessük össze a futási időket! https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apas03.html#id561066
        </para>
        <para>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:    <link xlink:href="https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Liskov!/Anti%20OO">https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Liskov!/Anti%20OO</link>           
        </para>
        <para>
        fordítás/futtatás:</para>
        <para> C:</para>
		<para>g++ pi_bbp_bench.c -o pi_bbp_bench -lm </para>
		<para>./pi_bbp_bench</para>

	 <para>C++</para>
	 	<para>g++ BBP_test.cpp -o bbpTest</para>
	 	<para>./bbpTest</para>
	 
	 <para>Java</para>
	 	<para>javac PiBBPBench.java</para>
	 	<para>java PiBBPBench </para>
	 
	 <para>C# </para>
	 	<para>mcs PiBBPBench.cs </para>
	 	<para>mono PiBBPBench.exe</para>
        
        <para>C:</para>
        <para>Kapott eredmények:</para>
         <para>C:</para>
        <para>10^6 =2,111283</para>
        <para>10^7 =24,401839</para>
        <para>10^8 =282,93285</para>
        
         <para>C++:</para>
        <para>10^6 =2,44803</para>
        <para>10^7 =27,7696</para>
        <para>10^8 =313,902</para>
        
        
         <para>Java:</para>
        <para>10^6 =1,883</para>
        <para>10^7 =22,144</para>
        <para>10^8 =248,324</para>
        
        
         <para>C#:</para>
        <para>10^6 =1,922333</para>
        <para>10^7 =22,595576</para>
        <para>10^8 =256,861381</para>
        
        
    </section>        

    <section>
        <title>Szülő-gyerek</title>
        <para>Írjunk Szülő-gyerek Java és C++ osztálydefiníciót, amelyben demonstrálni tudjuk, hogy az ősön keresztül csak az ős üzenetei küldhetőek!https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf(98. fólia)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:     <link xlink:href="https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Liskov!/Sz%C3%BCl%C5%91-gyerek">https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Liskov!/Sz%C3%BCl%C5%91-gyerek</link>      
        </para>
        <para>
            
        </para>
    </section>  
    
    <section>
        <title>Liskov helyettesítés sértése</title>
        <para>Írjunk olyan OO, leforduló Java és C++ kódcsipetet, amely megsérti a Liskov elvet! Mutassunk rá a megoldásra: jobb OO tervezés.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:   <link xlink:href="https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Liskov!/Liskov%20helyettes%C3%ADt%C3%A9s%20s%C3%A9rt%C3%A9se">https://github.com/grestemayster/prog2/tree/master/Hell%C3%B3%2C%20Liskov!/Liskov%20helyettes%C3%ADt%C3%A9s%20s%C3%A9rt%C3%A9se</link>            
        </para>
        <para>
        A Liskov-féle behelyettesítési elv, rövid nevén LSP a következőt mondja ki: </para>
        <para>Ha S osztály a T osztály leszármazottja, akkor S szabadon behelyettesíthető a programunkban minden olyan helyre (őaraméter,változó... ), ahol eredetileg T szülő típust várnánk
      	      
        </para>
        <para>
            fordítás/futtatás:
        </para>
        <para>C++</para>
	 	<para>g++ Liskovsertes.cpp -o Liskovsertes</para>
	 	<para>./Liskovsertes</para>
	 
	 <para>Java</para>
	 	<para>javac Liskovsertes.java </para>
	 	<para>java Liskovsertes</para>
	 <para></para>
	 <para>Mind a kettő esetben azt kapjuk vissza, hogy az Ebr tud láncot javítani, ami nem lehetséges mert az ebr egy kerekes tank.</para>
	 	
	 	
	
    </section> 


    <section>
        <title>EPAM:
Interfész evolúció Java ban</title>
        <para>Írjunk Szülő-gyerek Java és C++ osztálydefiníciót, amelyben demonstrálni tudjuk, hogy az ősön keresztül csak az ős üzenetei küldhetőek!https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf(98. fólia)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para> A Java 7 2011-ben jelent meg.   </para>           
        <para>Ez volt az első nagyobb Java-frissítés, miután az Oracle megszerezte a Sun Microsystems-t.  </para>
        <para> A Java 7 a végső Java-verzió, amely hivatalosan támogatná a Windows XP-t.</para>
        <para> </para>
        <para>A Java 7 tartalmazott néhány olyan főbb funkciót, mint például: </para>
        <para>Tömörített 64 bites mutatók.</para>
        <para>Frissített class-loader architektúra.</para>
        <para>Több kivétel kezelése.</para>
        <para>JVM támogatás a nyelvek dinamikus támogatásához.</para>
        <para>Frissített 1.1 sor és JDBC 4.1.</para>
        <para>Karakterlánc objektum egy kapcsoló utasításban.</para>
        <para>Automatikus erőforrás-kezelés try utasításban és még sok más. </para>
        <para> </para>
        <para>Java7 vs. Java8 </para>
        <para> Lambda kifejezések</para>
        <para> A lambda kifejezések csak törzset és paraméterlistát tartalmaznak.</para>
        <para> A Lambda Expressions használatának előnyei,</para>
        <para> Továbbfejlesztett iteratív szintaxis.</para>
        <para> Olvashatóság.</para>
        <para> Kód újrafelhasználása.</para>
        <para> JAR fájlméret csökkentése.</para>
        <para>Egyszerűsített változó hatóköre.</para>
        <para> A funkcionális programozás ösztönzése.</para>
        <para> Null Referencia Sablon,Nevezhetjük Java Opcionális Osztálynak is.</para>
        <para> A Java Optional osztály használatának előnyei: </para>
        <para>Nincs semmiféle kivétel a futás közben. </para>
        <para>Tiszta API-k fejleszthetők. </para>
        <para>Nincs szükség semmilyen ellenőrzésre.</para>
        <para>Új dátum és idő API </para>
        <para> A java.util.Date osztályban az évek 1900-tól kezdődnek, a hónapok pedig 0-tól kezdődnek. Ezért fontos tudni, mivel amikor egy évet és egy hónapot szeretnénk kijelölni, annak a következőnek kell lennie: (ÉÉÉÉ-1900) és (HH) -1). Ezt a Java 8 legyőzte a java.time csomagban található osztályok használatával.</para>
        <para>Az egész számtól vagy a karaktersorozattól eltérõen a Dátum osztály változtatható. Ami azt jelenti, hogy a dátum megváltoztatható a tulajdonos osztály tudta nélkül. A Java 8 rendelkezik erre megoldással. A Java 8-ban bevezetett LocalDate, LocalTime, LocalDateTime stb. Változhatatlanok (az eredeti objektum nem változik. Valahányszor változtatás történik, egy új objektum kerül visszaadásra). </para>
        <para> Unsigned Integer Arithmetic</para>
        <para> Nem világos, hogy a Java 8 mit próbált elérni az előjel nélküli egész számtani előrehaladással. De általában egy előjel nélküli egész szám károsnak tekinthető a Java-ra. Bonyolultabbá teszi a típusátalakító eszközöket, a típusrendszert és a könyvtár API-kat.</para>
        <para> Stream API</para>
        <para> A Stream API használatának legfőbb előnye, hogy egyértelműen növeli a program sebességét és hatékonyságát. Javában erőműnek számít.</para>
        <para> Párhuzamos rendezés</para>
        <para> A párhuzamos rendezés több szálat használ a művelethez. Gyorsan és hatékonyan teszi a programot. Ez nem lesz annyira látható egy kis adathalmaz mellett. De ha nagy adatkészletet használunk, a hatékonyság és a teljesítmény növekedése nagyon észrevehető lesz.</para>
        <para> Új JavaScript motor</para>
        <para>A Java 8-mal bevezetett JavaScript-motor neve Nashorn volt. </para>
        <para> </para>
        
        
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
